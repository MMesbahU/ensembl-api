
=pod 

=head1 NAME

Bio::EnsEMBL::Compara::RunnableDB::LoadOneGenomeDB

=head1 DESCRIPTION

This Runnable loads one entry into 'genome_db' table and passes on the genome_db_id.

The format of the input_id follows the format of a Perl hash reference.
Examples:
    { 'species_name' => 'Homo sapiens', 'assembly_name' => 'GRCh37' }
    { 'species_name' => 'Mus musculus' }

supported keys:
    'locator'       => <string>
        one of the ways to specify the connection parameters to the core database (overrides 'species_name' and 'assembly_name')

    'registry_dbs'  => <list_of_dbconn_hashes>
        another, simple way to specify the genome_db (and let the registry search across multiple mysql instances to do the rest)
    'species_name'  => <string>
        mandatory, but what would you expect?

    'first_found'   => <0|1>
        optional, defaults to 0.
        Defines whether we emulate (to a certain extent) the behaviour of load_registry_from_multiple_dbs
        or try the last one that still fits (this would allow to try ens-staging[12] *first*, and only then check if ens-livemirror has is a suitable copy).

    'assembly_name' => <string>
        optional: in most cases it should be possible to find the species just by using 'species_name'

    'genome_db_id'  => <integer>
        optional, in case you want to specify it (otherwise it will be generated by the adaptor when storing)

    'pseudo_stableID_prefix' => <string>
        optional?, see 'GenomeLoadMembers.pm', 'GenomeLoadReuseMembers.pm', 'GeneStoreNCMembers.pm', 'GenomePrepareNCMembers.pm'

    'ensembl_genomes' => <0|1>
        optional, sets the preferential order of precedence of species_name sources, depending on whether the module is run by EG or Compara

=cut

package Bio::EnsEMBL::Compara::RunnableDB::ProteinTrees::FromScratch::StoreMembersSequence;

use strict;
use Bio::Perl;
use Bio::EnsEMBL::Registry;
use Bio::EnsEMBL::DBLoader;
use Bio::EnsEMBL::Compara::GenomeDB;
use Bio::EnsEMBL::Compara::Member;
use Bio::EnsEMBL::Compara::Subset;

use Data::Dumper;

use base ('Bio::EnsEMBL::Compara::RunnableDB::BaseRunnable');


sub fetch_input {
	my $self = shift @_;

	# Adaptors
	my $compara_dba = $self->compara_dba();
	$self->param('member_adaptor', $compara_dba->get_MemberAdaptor());

	$self->param('genome_db_id', $compara_dba->get_GenomeDBAdaptor->fetch_by_taxon_id($self->param('ncbi_taxon_id'))->dbID );

	$self->param('pepSubset', Bio::EnsEMBL::Compara::Subset->new(-name => ("gdb:".($self->param('genome_db_id'))." ".($self->param('species_name')).' translations')));
	$self->param('geneSubset', Bio::EnsEMBL::Compara::Subset->new(-name => ("gdb:".($self->param('genome_db_id'))." ".($self->param('species_name')).' genes')));

	$self->param('subset_adaptor', $compara_dba->get_SubsetAdaptor());
	$self->param('subset_adaptor')->store($self->param('pepSubset'));
	$self->param('subset_adaptor')->store($self->param('geneSubset'));

}

sub run {
	my $self = shift @_;

	my $genome_db_id = $self->param('genome_db_id');
	my $member_adaptor = $self->param('member_adaptor');

	# FASTA file
	my @allseq = read_all_sequences($self->param('data_dir')."/".$self->param('filename'));
	print scalar(@allseq), " sequences read in ", $self->param('filename'), " (taxon_id: ", $self->param('ncbi_taxon_id'), " taxon_name: ", $self->param('species_name'), ")\n" if ($self->debug);

	my $count = 0;
	foreach my $sequence (@allseq) {
		
		$count++;

		my @t = split(":", $sequence->id);
		
		print "sequence $count: name ", $sequence->id, "\n" if ($self->debug > 1);
		print "sequence $count: description ", $sequence->desc, "\n" if ($self->debug > 1);
		print "sequence $count: length ", $sequence->length, "\n" if ($self->debug > 1);

		my $gene_member = Bio::EnsEMBL::Compara::Member->new();
		$gene_member->stable_id(sprintf("GENE%06d%06d", $self->param('ncbi_taxon_id'), $count));
		$gene_member->display_label($t[1]);
		$gene_member->source_name("ENSEMBLGENE");
		$gene_member->taxon_id($self->param('ncbi_taxon_id'));
		$gene_member->description($sequence->id." ".$sequence->desc);
		$gene_member->genome_db_id($genome_db_id);
		$member_adaptor->store($gene_member);
		$self->param('geneSubset')->add_member($gene_member);

		my $pep_member = Bio::EnsEMBL::Compara::Member->new();
		$pep_member->stable_id(sprintf("PEPT%06d%06d", $self->param('ncbi_taxon_id'), $count));
		$pep_member->display_label($t[1]);
		$pep_member->source_name("ENSEMBLPEP");
		$pep_member->taxon_id($self->param('ncbi_taxon_id'));
		$pep_member->description($sequence->id." ".$sequence->desc);
		$pep_member->genome_db_id($genome_db_id);
		my $seq = $sequence->seq;
		$seq =~ s/O/X/g;
		$pep_member->sequence($seq);
		$member_adaptor->store($pep_member);
		$self->param('pepSubset')->add_member($pep_member);

		$member_adaptor->store_gene_peptide_link($gene_member->dbID, $pep_member->dbID);

	};

	print $self->param('geneSubset')->count(), " genes and ", $self->param('pepSubset')->count(), " peptides in subsets\n" if ($self->debug);
}

sub write_output {      # dataflow

	my $self = shift;

	$self->dataflow_output_id( { 'genome_db_id' => $self->param('genome_db_id'), 'species_name' => $self->param('species_name') } , 1);
}


1;

